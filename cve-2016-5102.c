//CVE-2016-5102
int
readgifimage(char* mode)
{
    unsigned char buf[9];
    int local, interleaved;
    unsigned char localmap[256][3];
    int localbits;
    int status;
    size_t raster_size;

    if (fread(buf, 1, 9, infile) != 9) {
        fprintf(stderr, "short read from file %s (%s)\n",
                filename, strerror(errno));
	return (0);
    }
    width = (buf[4] + (buf[5] << 8)) & 0xffff; /* 16 bit */
    height = (buf[6] + (buf[7] << 8)) & 0xffff;  /* 16 bit */
    local = buf[8] & 0x80;
    interleaved = buf[8] & 0x40;
    if (width == 0UL || height == 0UL || (width > 2000000000UL / height)) {
        fprintf(stderr, "Invalid value of width or height\n");
        return(0);
    }
    if (local == 0 && global == 0) {
        fprintf(stderr, "no colormap present for image\n");
        return (0);
    }
    raster_size=width*height;
    if ((raster_size/width) == height) {
        raster_size += EXTRAFUDGE;  /* Add elbow room */
    } else {
        raster_size=0;
    }
    if ((raster = (unsigned char*) _TIFFmalloc(raster_size)) == NULL) {
        fprintf(stderr, "not enough memory for image\n");
        return (0);
    }
    if (local) {
        localbits = (buf[8] & 0x7) + 1;

        fprintf(stderr, "   local colors: %d\n", 1<<localbits);

        if (fread(localmap, 3, ((size_t)1)<<localbits, infile) !=
            ((size_t)1)<<localbits) {
            fprintf(stderr, "short read from file %s (%s)\n",
                    filename, strerror(errno));
            return (0);
        }
        initcolors(localmap, 1<<localbits);
    } else if (global) {
        initcolors(globalmap, 1<<globalbits);
    }
    if ((status = readraster()))
	rasterize(interleaved, mode);
    _TIFFfree(raster);
    return status;
}