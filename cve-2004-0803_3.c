static int
LogL16Decode(TIFF* tif, tidata_t op, tsize_t occ, tsample_t s)
{
	LogLuvState* sp = DecoderState(tif);
	int shft, i, npixels;
	u_char* bp;
	int16* tp;
	int16 b;
	int cc, rc;

	assert(s == 0);
	assert(sp != NULL);

	npixels = occ / sp->pixel_size;

	if (sp->user_datafmt == SGILOGDATAFMT_16BIT)
		tp = (int16*) op;
	else {
		assert(sp->tbuflen >= npixels);
		tp = (int16*) sp->tbuf;
	}
	_TIFFmemset((tdata_t) tp, 0, npixels*sizeof (tp[0]));

	bp = (u_char*) tif->tif_rawcp;
	cc = tif->tif_rawcc;
					/* get each byte string */
	for (shft = 2*8; (shft -= 8) >= 0; ) {
		for (i = 0; i < npixels && cc > 0; )
			if (*bp >= 128) {		/* run */
				rc = *bp++ + (2-128);
				b = (int16)(*bp++ << shft);
				cc -= 2;
				while (rc--)
					tp[i++] |= b;
			} else {			/* non-run */
				rc = *bp++;		/* nul is noop */
				while (--cc && rc--)
					tp[i++] |= (int16)*bp++ << shft;
			}
		if (i != npixels) {
			TIFFError(tif->tif_name,
		"LogL16Decode: Not enough data at row %d (short %d pixels)",
			    tif->tif_row, npixels - i);
			tif->tif_rawcp = (tidata_t) bp;
			tif->tif_rawcc = cc;
			return (0);
		}
	}
	(*sp->tfunc)(sp, op, npixels);
	tif->tif_rawcp = (tidata_t) bp;
	tif->tif_rawcc = cc;
	return (1);
}