//CVE-2004-0929
static int
OJPEGVSetField(register TIFF *tif,ttag_t tag,va_list ap)
{
    uint32 v32;
    register OJPEGState *sp = OJState(tif);
#   define td (&tif->tif_dir)
    toff_t tiffoff=0;
    uint32 bufoff=0;
    uint32 code_count=0;
    int i2=0;
    int k2=0;

    switch (tag)
      {

     /* If a "ReferenceBlackWhite" TIFF tag appears in the file explicitly, undo
        any modified default definition that we might have installed below, then
        install the real one.
     */
        case TIFFTAG_REFERENCEBLACKWHITE   : if (td->td_refblackwhite)
                                               {
                                                 _TIFFfree(td->td_refblackwhite);
                                                 td->td_refblackwhite = 0;
                                               };
        default                            : return
                                               (*sp->vsetparent)(tif,tag,ap);

     /* BEWARE OF KLUDGE:  Some old-format JPEG-in-TIFF files, including those
                           produced by the Wang Imaging application for Micro-
        soft Windows, illegally omit a "ReferenceBlackWhite" TIFF tag, even
        though the TIFF specification's default is intended for the RGB color
        space and is inappropriate for the YCbCr color space ordinarily used for
        JPEG images.  Since many TIFF client applications request the value of
        this tag immediately after a TIFF image directory is parsed, and before
        any other code in this module receives control, we are forced to fix
        this problem very early in image-file processing.  Fortunately, legal
        TIFF files are supposed to store their tags in numeric order, so a
        mandatory "PhotometricInterpretation" tag should always appear before
        an optional "ReferenceBlackWhite" tag.  Hence, we slyly peek ahead when
        we discover the desired photometry, by installing modified black and
        white reference levels.
     */
        case TIFFTAG_PHOTOMETRIC           :
          if (   (v32 = (*sp->vsetparent)(tif,tag,ap))
              && td->td_photometric == PHOTOMETRIC_YCBCR
             )
	  {
            if ( (td->td_refblackwhite = _TIFFmalloc(6*sizeof(float))) )
              { register long top = 1 << td->td_bitspersample;

                td->td_refblackwhite[0] = 0;
                td->td_refblackwhite[1] = td->td_refblackwhite[3] =
                td->td_refblackwhite[5] = top - 1;
                td->td_refblackwhite[2] = td->td_refblackwhite[4] = top >> 1;
              }
            else
              {
                TIFFError(tif->tif_name,
                  "Cannot set default reference black and white levels");
                v32 = 0;
              };
	  }
          return v32;

     /* BEWARE OF KLUDGE:  According to Charles Auer <Bumble731@msn.com>, if our
                           input is a multi-image (multi-directory) JPEG-in-TIFF
        file is produced by the Wang Imaging application on Microsoft Windows,
        for some reason the first directory excludes the vendor-specific "WANG
        PageControl" tag (32934) that we check below, so the only other way to
        identify these directories is apparently to look for a software-
        identification tag with the substring, "Wang Labs".  Single-image files
        can apparently pass both tests, which causes no harm here, but what a
        mess this is!
     */
        case TIFFTAG_SOFTWARE              :
        {
            char *software;

            v32 = (*sp->vsetparent)(tif,tag,ap);
            if( TIFFGetField( tif, TIFFTAG_SOFTWARE, &software )
                && strstr( software, "Wang Labs" ) )
                sp->is_WANG = 1;
            return v32;
        }

        case TIFFTAG_JPEGPROC              :
        case TIFFTAG_JPEGIFOFFSET          :
        case TIFFTAG_JPEGIFBYTECOUNT       :
        case TIFFTAG_JPEGRESTARTINTERVAL   :
        case TIFFTAG_JPEGLOSSLESSPREDICTORS:
        case TIFFTAG_JPEGPOINTTRANSFORM    :
        case TIFFTAG_JPEGQTABLES           :
        case TIFFTAG_JPEGDCTABLES          :
        case TIFFTAG_JPEGACTABLES          :
        case TIFFTAG_WANG_PAGECONTROL      :
        case TIFFTAG_JPEGCOLORMODE         : ;
      };
    v32 = va_arg(ap,uint32); /* No. of values in this TIFF record */

    /* This switch statement is added for OJPEGVSetField */
    if(v32 !=0){
        switch(tag){
            case TIFFTAG_JPEGPROC:
                sp->jpegproc=v32;
                break;
            case TIFFTAG_JPEGIFOFFSET:
                sp->jpegifoffset=v32;
		break;
            case TIFFTAG_JPEGIFBYTECOUNT:
		sp->jpegifbytecount=v32;
		break;
            case TIFFTAG_JPEGRESTARTINTERVAL:
		sp->jpegrestartinterval=v32;
		break;
            case TIFFTAG_JPEGLOSSLESSPREDICTORS:
		sp->jpeglosslesspredictors_length=v32;
		break;
            case TIFFTAG_JPEGPOINTTRANSFORM:
		sp->jpegpointtransform_length=v32;
		break;
            case TIFFTAG_JPEGQTABLES:
		sp->jpegqtables_length=v32;
		break;
            case TIFFTAG_JPEGACTABLES:
		sp->jpegactables_length=v32;
		break;
            case TIFFTAG_JPEGDCTABLES:
		sp->jpegdctables_length=v32;
		break;
            default:
		break;
        }
    }

 /* BEWARE:  The following actions apply only if we are reading a "source" TIFF
             image to be decompressed for a client application program.  If we
    ever enhance this file's CODEC to write "destination" JPEG-in-TIFF images,
    we'll need an "if"- and another "switch"-statement below, because we'll
    probably want to store these records' values in some different places.  Most
    of these need not be parsed here in order to decode JPEG bit stream, so we
    set boolean flags to note that they have been seen, but we otherwise ignore
    them.
 */
    switch (tag)
      { JHUFF_TBL **h;

     /* Validate the JPEG-process code. */

        case TIFFTAG_JPEGPROC              :
          switch (v32)
            {
              default               : TIFFError(tif->tif_name,
                                        "Unknown JPEG process");
                                      return 0;
#             ifdef C_LOSSLESS_SUPPORTED

           /* Image uses (lossy) baseline sequential coding. */

              case JPEGPROC_BASELINE: sp->cinfo.d.process = JPROC_SEQUENTIAL;
                                      sp->cinfo.d.data_unit = DCTSIZE;
                                      break;

           /* Image uses (lossless) Huffman coding. */

              case JPEGPROC_LOSSLESS: sp->cinfo.d.process = JPROC_LOSSLESS;
                                      sp->cinfo.d.data_unit = 1;
#             else /* not C_LOSSLESS_SUPPORTED */
              case JPEGPROC_LOSSLESS: TIFFError(JPEGLib_name,
                                        "Does not support lossless Huffman coding");
                                      return 0;
              case JPEGPROC_BASELINE: ;
#             endif /* C_LOSSLESS_SUPPORTED */
            };
          break;

     /* The TIFF Version 6.0 specification says that if the value of a TIFF
        "JPEGInterchangeFormat" record is 0, then we are to behave as if this
        record were absent; i.e., the data does *not* represent a JPEG Inter-
        change Format File (JFIF), so don't even set the boolean "I've been
        here" flag below.  Otherwise, the field's value represents the file
        offset of the JPEG SOI marker.
     */
        case TIFFTAG_JPEGIFOFFSET          :
          if (v32)
            {
              sp->src.next_input_byte = tif->tif_base + v32;
              break;
            };
          return 1;
        case TIFFTAG_JPEGIFBYTECOUNT       :
          sp->src.bytes_in_buffer = v32;
          break;

     /* The TIFF Version 6.0 specification says that if the JPEG "Restart"
        marker interval is 0, then the data has no "Restart" markers; i.e., we
        must behave as if this TIFF record were absent.  So, don't even set the
        boolean "I've been here" flag below.
     */
     /*
      * Instead, set the field bit so TIFFGetField can get whether or not
      * it was set.
      */
        case TIFFTAG_JPEGRESTARTINTERVAL   :
          if (v32)
              sp->cinfo.d.restart_interval = v32;
              break;
     /* The TIFF Version 6.0 specification says that this tag is supposed to be
        a vector containing a value for each image component, but for lossless
        Huffman coding (the only JPEG process defined by the specification for
        which this tag should be needed), ISO IS 10918-1 uses only a single
        value, equivalent to the "Ss" field in a JPEG bit-stream's "Start of
        Scan" (SOS) marker.  So, we extract the first vector element and ignore
        the rest.  (I hope this is correct!)
     */
        case TIFFTAG_JPEGLOSSLESSPREDICTORS:
           if (v32)
             {
               sp->cinfo.d.Ss = *va_arg(ap,uint16 *);
               sp->jpeglosslesspredictors = 
		    _TIFFmalloc(sp->jpeglosslesspredictors_length
				* sizeof(uint16));
               if(sp->jpeglosslesspredictors==NULL){return(0);}
               for(i2=0;i2<sp->jpeglosslesspredictors_length;i2++){
                ((uint16*)sp->jpeglosslesspredictors)[i2] =
			((uint16*)sp->cinfo.d.Ss)[i2];
               }
               sp->jpeglosslesspredictors_length*=sizeof(uint16);
               break;
             };
           return v32;

     /* The TIFF Version 6.0 specification says that this tag is supposed to be
        a vector containing a value for each image component, but for lossless
        Huffman coding (the only JPEG process defined by the specification for
        which this tag should be needed), ISO IS 10918-1 uses only a single
        value, equivalent to the "Al" field in a JPEG bit-stream's "Start of
        Scan" (SOS) marker.  So, we extract the first vector element and ignore
        the rest.  (I hope this is correct!)
     */
        case TIFFTAG_JPEGPOINTTRANSFORM    :
           if (v32)
             {
               sp->cinfo.d.Al = *va_arg(ap,uint16 *);
               sp->jpegpointtransform =
		    _TIFFmalloc(sp->jpegpointtransform_length*sizeof(uint16));
               if(sp->jpegpointtransform==NULL){return(0);}
               for(i2=0;i2<sp->jpegpointtransform_length;i2++) {
                ((uint16*)sp->jpegpointtransform)[i2] =
			((uint16*)sp->cinfo.d.Al)[i2];
               }
               sp->jpegpointtransform_length*=sizeof(uint16);
               break;
             }
           return v32;

     /* We have a vector of offsets to quantization tables, so load 'em! */

        case TIFFTAG_JPEGQTABLES           :
          if (v32)
            { uint32 *v;
              int i;
              if (v32 > NUM_QUANT_TBLS)
                {
                  TIFFError(tif->tif_name,"Too many quantization tables");
                  return 0;
                };
              i = 0;
              v = va_arg(ap,uint32 *);
                sp->jpegqtables=_TIFFmalloc(64*sp->jpegqtables_length);
                if(sp->jpegqtables==NULL){return(0);}
                tiffoff = TIFFSeekFile(tif, 0, SEEK_CUR);
                bufoff=0;
                for(i2=0;i2<sp->jpegqtables_length;i2++){
                    TIFFSeekFile(tif, v[i2], SEEK_SET);
                    TIFFReadFile(tif, &(((u_char*)(sp->jpegqtables))[bufoff]),
				 64);
                    bufoff+=64;
                }
                sp->jpegqtables_length=bufoff;
                TIFFSeekFile(tif, tiffoff, SEEK_SET);

              do /* read quantization table */
                { register UINT8 *from = tif->tif_base + *v++;
                  register UINT16 *to;
                  register int j = DCTSIZE2;

                  if (!( sp->cinfo.d.quant_tbl_ptrs[i]
                       = CALLJPEG(sp,0,jpeg_alloc_quant_table(&sp->cinfo.comm))
                       )
                     )
                    {
                      TIFFError(JPEGLib_name,"No space for quantization table");
                      return 0;
                    };
                  to = sp->cinfo.d.quant_tbl_ptrs[i]->quantval;
                  do *to++ = *from++; while (--j > 0);
                }
              while (++i < v32);
              sp->jpegtablesmode |= JPEGTABLESMODE_QUANT;
            };
          break;

     /* We have a vector of offsets to DC Huffman tables, so load 'em! */

        case TIFFTAG_JPEGDCTABLES          :
          h = sp->cinfo.d.dc_huff_tbl_ptrs;
          goto L;

     /* We have a vector of offsets to AC Huffman tables, so load 'em! */

        case TIFFTAG_JPEGACTABLES          :
          h = sp->cinfo.d.ac_huff_tbl_ptrs;
       L: if (v32)
            { uint32 *v;
              int i;
              if (v32 > NUM_HUFF_TBLS)
                {
                  TIFFError(tif->tif_name,"Too many Huffman tables");
                  return 0;
                };
              v = va_arg(ap,uint32 *);
                if(tag == TIFFTAG_JPEGDCTABLES) {
                    sp->jpegdctables=_TIFFmalloc(272*sp->jpegdctables_length);
                    if(sp->jpegdctables==NULL){return(0);}
                    tiffoff = TIFFSeekFile(tif, 0, SEEK_CUR);
                    bufoff=0;
                    code_count=0;                
                    for(i2=0;i2<sp->jpegdctables_length;i2++){
                        TIFFSeekFile(tif, v[i2], SEEK_SET);
                        TIFFReadFile(tif,
				     &(((u_char*)(sp->jpegdctables))[bufoff]),
				     16);
                        code_count=0;
                        for(k2=0;k2<16;k2++){
                            code_count+=((u_char*)(sp->jpegdctables))[k2+bufoff];
                        }
                        TIFFReadFile(tif,
				     &(((u_char*)(sp->jpegdctables))[bufoff+16]),
				     code_count);
                        bufoff+=16;
                        bufoff+=code_count;
                    }
                    sp->jpegdctables_length=bufoff;
                    TIFFSeekFile(tif, tiffoff, SEEK_SET);
                }
                if(tag==TIFFTAG_JPEGACTABLES){
                    sp->jpegactables=_TIFFmalloc(272*sp->jpegactables_length);
                    if(sp->jpegactables==NULL){return(0);}
                    tiffoff = TIFFSeekFile(tif, 0, SEEK_CUR);
                    bufoff=0;
                    code_count=0;                
                    for(i2=0;i2<sp->jpegactables_length;i2++){
                        TIFFSeekFile(tif, v[i2], SEEK_SET);
                        TIFFReadFile(tif, &(((unsigned char*)(sp->jpegactables))[bufoff]), 16);
                        code_count=0;
                        for(k2=0;k2<16;k2++){
                            code_count+=((unsigned char*)(sp->jpegactables))[k2+bufoff];
                        }
                        TIFFReadFile(tif, &(((unsigned char*)(sp->jpegactables))[bufoff+16]), code_count);
                        bufoff+=16;
                        bufoff+=code_count;
                    }
                    sp->jpegactables_length=bufoff;
                    TIFFSeekFile(tif, tiffoff, SEEK_SET);
                }
              i = 0;
              do /* copy each Huffman table */
                { int size = 0;
                  register UINT8 *from = tif->tif_base + *v++, *to;
                  register int j = sizeof (*h)->bits;

               /* WARNING:  This code relies on the fact that an image file not
                            "memory mapped" was read entirely into a single
                  buffer by "TIFFInitOJPEG()", so we can do a fast memory-to-
                  memory copy here.  Each table consists of 16 Bytes, which are
                  suffixed to a 0 Byte when copied, followed by a variable
                  number of Bytes whose length is the sum of the first 16.
               */
                  if (!( *h
                       = CALLJPEG(sp,0,jpeg_alloc_huff_table(&sp->cinfo.comm))
                       )
                     )
                    {
                      TIFFError(JPEGLib_name,"No space for Huffman table");
                      return 0;
                    };
                  to = (*h++)->bits;
                  *to++ = 0;
                  while (--j > 0) size += *to++ = *from++; /* Copy 16 Bytes */
                  if (size > sizeof (*h)->huffval/sizeof *(*h)->huffval)
                    {
                      TIFFError(tif->tif_name,"Huffman table too big");
                      return 0;
                    };
                  if ((j = size) > 0) do *to++ = *from++; while (--j > 0);
                  while (++size <= sizeof (*h)->huffval/sizeof *(*h)->huffval)
                    *to++ = 0; /* Zero the rest of the table for cleanliness */
                }
              while (++i < v32);
              sp->jpegtablesmode |= JPEGTABLESMODE_HUFF;
            };
          break;

     /* The following vendor-specific TIFF tag occurs in (highly illegal) files
        produced by the Wang Imaging application for Microsoft Windows.  These
        can apparently have several "pages", in which case this tag specifies
        the offset of a "page control" structure, which we don't currently know
        how to handle.  0 indicates a 1-page image with no "page control", which
        we make a feeble effort to handle.
     */
        case TIFFTAG_WANG_PAGECONTROL      :
          if (v32 == 0) v32 = -1;
          sp->is_WANG = v32;
          tag = TIFFTAG_JPEGPROC+FIELD_WANG_PAGECONTROL-FIELD_JPEGPROC;
          break;

     /* This pseudo tag indicates whether our caller is expected to do YCbCr <->
        RGB color-space conversion (JPEGCOLORMODE_RAW <=> 0) or whether we must
        ask the JPEG Library to do it (JPEGCOLORMODE_RGB <=> 1).
     */
        case TIFFTAG_JPEGCOLORMODE         :
          sp->jpegcolormode = v32;

       /* Mark the image to indicate whether returned data is up-sampled, so
          that "TIFF{Strip,Tile}Size()" reflect the true amount of data present.
       */
          v32 = tif->tif_flags; /* Save flags temporarily */
          tif->tif_flags &= ~TIFF_UPSAMPLED;
          if (   td->td_photometric == PHOTOMETRIC_YCBCR
              &&    (td->td_ycbcrsubsampling[0]<<3 | td->td_ycbcrsubsampling[1])
                 != 011
              && sp->jpegcolormode == JPEGCOLORMODE_RGB
             ) tif->tif_flags |= TIFF_UPSAMPLED;

       /* If the up-sampling state changed, re-calculate tile size. */

          if ((tif->tif_flags ^ v32) & TIFF_UPSAMPLED)
            {
              tif->tif_tilesize = TIFFTileSize(tif);
              tif->tif_flags |= TIFF_DIRTYDIRECT;
            };
          return 1;
      };
    TIFFSetFieldBit(tif,tag-TIFFTAG_JPEGPROC+FIELD_JPEGPROC);
    return 1;
#   undef td
  }